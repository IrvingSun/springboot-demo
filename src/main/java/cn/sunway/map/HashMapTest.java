package cn.sunway.map;

import java.util.HashMap;
import java.util.Map;

/**
 *
 * HashMap主要用来存放键值对，基于哈希表的Map接口实现。
 可以存储null key，只允许一个。
 1.8之前，是由数组+链表实现，数组是主体，链表主要是为了解决hash冲突而存在。
 1.8以后，对解决Hash冲突有了比较大的改动，
 如果链表长度大于8，如果数组长度小于64，则扩充数组
 如果链表长度大于8，如果数组长度不小于64，则将链表转成红黑树，以减少搜索时间
 数组默认大小16，扩容增加为2倍大小，以2次幂作为哈希表的大小，负载因子0.75。
 - hashCode（String）使用31作为乘积
 质奇数（2是质数，但是不是奇数）增加随机性，可以让key均匀分布
 扰动函数：hashcode是整数，32位，高16^低16位，增加随机性，减少碰撞
 数组大小：寻找最近的2次幂数字，使用无符号右移，高位补0
 static final int tableSizeFor(int cap) {
 int n = cap - 1;
 n |= n >>> 1;
 n |= n >>> 2;
 n |= n >>> 4;
 n |= n >>> 8;
 n |= n >>> 16;
 return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
 }
 使用右移 + |，将二进制各位都填充上1，开始的-1是为了兼容cap是2的倍数的情况
 各位都填充1之后，当前的值就是一个标准的2次幂-1了，+1就是最小的的2次幂
 -数据迁移
 计算新位置，以16扩容到32为例：
 数组长度变为原来长度的一倍：32，新增长度16
 位置变化：如果key的hash值与16相与& 值为0，则位置不变，如果不为0，则新位置，则是原位置+16
 -插入流程
 1、进行hash值的扰动，计算出一个新的hash值
 2、判断数组是否为空，如果为空，扩容
 3、根据hash值计算下标，如果下标位置为空，则直接插入即可，否则需要覆盖
 4、如果节点是链表，则在链表尾部插入数据，如果为树，则插入树中
 5、如果是链表节点：
 * 遍历链表，找到第一个key的hash值，并且key值相等的节点，替换值
 * 如果没有找到，则表示需要往链表尾部插入数据
 * 插入数据之前，先要看链表是否长度已经大于等于7
 * 如果大于等于7，则走扩容流程，如果总元素个数小于64，则不考虑树化，直接扩容数组长度，如果总元素不小于64，则树化
 * modCount++
 * 如果元素大小超过阈值，则需要重新扩容一次
 * 红黑树转链表阈值，6
 红黑树的平均查找长度是log(n)，如果长度为8，平均查找长度为log(8)=3，链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，这才有转换成树的必要；链表长度如果是小于等于6，6/2=3，而log(6)=2.6，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。
 -线程不安全
 modCount++
 size++
 put覆盖
 扩容引起get到null值
 …
 * @author sunw
 * @date 2023/3/20
 */
public class HashMapTest {
    public static void main(String[] args) {
        Map<String,String> map = new HashMap<>();
    }
}
